import { h } from '/lib/preact/mod.js';
import { useWasmInterface } from '/js/WasmInterfaceProvider.js';

// build the Preact structure from the AST generated by rust
//
export default function buildMarkup(content, imageDirectory) {
    const wasmInterface = useWasmInterface();
    const astArray = wasmInterface.asHtmlAst(content);

    function attrs(n) {
        const res = { key: n.key };
        if (n.class_name) { res.class = n.class_name; }
        if (n.id)         { res.id = n.id; }
        if (n.html_for)   { res.for = n.html_for; }
        if (n.href)       { res.href = n.href; }
        if (n.html_type)  { res.type = n.html_type; }
        if (n.src)        { res.src = `/u/${imageDirectory}/${n.src}`; }
        if (n.start)      { res.start = n.start; }

        return res;
    }

    function assignPseudoParagraph(klass) {
        let c = klass || "";
        c += " pseudo-paragraph";
        return c.trim();
    }

    function compile(n, pDepth) {
        if (n.name === "text") {
            return n.text;
        } else if(n.name === "p") {
            if (pDepth > 0) {
                // we have a nested paragraph (e.g. text in the right-hand margin created by the pipe syntax)
                // as html's <p> tag cannot be nested, use a span with a custom class
                //
                let modified_attrs = attrs(n);
                modified_attrs.class = assignPseudoParagraph(modified_attrs.class);
                return h("span", modified_attrs, ...n.children.map(child => { return compile(child, pDepth + 1)}));
            } else {
                return h(n.name, attrs(n), ...n.children.map(child => { return compile(child, pDepth + 1)}));
            }
        } else {
            return h(n.name, attrs(n), ...n.children.map(child => { return compile(child, pDepth)}));
        }
    }

    return astArray.map(node => { return compile(node, 0)});
}
