{"version":3,"file":"signals-core.mjs","sources":["../src/index.ts"],"sourcesContent":["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// Flags for Nodes.\nconst NODE_FREE = 1 << 0;\nconst NODE_SUBSCRIBED = 1 << 1;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A node may have the following flags:\n\t//  NODE_FREE when it's unclear whether the source is still a dependency of the target\n\t//  NODE_SUBSCRIBED when the target has subscribed to listen change notifications from the source\n\t_flags: number;\n\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && effect._flags & OUTDATED) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t// `signal` is a new dependency. Create a new node dependency node, move it\n\t\t//  to the front of the current context's dependency list.\n\t\tnode = {\n\t\t\t_flags: 0,\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: undefined,\n\t\t\t_nextSource: evalContext._sources,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._flags & NODE_FREE) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse the dependency\n\t\t// node and move it to the front of the evaluation context's dependency list.\n\t\tnode._flags &= ~NODE_FREE;\n\n\t\tconst head = evalContext._sources;\n\t\tif (node !== head) {\n\t\t\tconst prev = node._prevSource;\n\t\t\tconst next = node._nextSource;\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = next;\n\t\t\t}\n\t\t\tif (next !== undefined) {\n\t\t\t\tnext._prevSource = prev;\n\t\t\t}\n\t\t\tif (head !== undefined) {\n\t\t\t\thead._prevSource = node;\n\t\t\t}\n\t\t\tnode._prevSource = undefined;\n\t\t\tnode._nextSource = head;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/** @internal */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\tpeek(): T;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (!(node._flags & NODE_SUBSCRIBED)) {\n\t\tnode._flags |= NODE_SUBSCRIBED;\n\t\tnode._nextTarget = this._targets;\n\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\tif (node._flags & NODE_SUBSCRIBED) {\n\t\tnode._flags &= ~NODE_SUBSCRIBED;\n\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(value) {\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._flags |= NODE_FREE;\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\t// At this point target._sources is a mishmash of current & former dependencies.\n\t// The current dependencies are also in a reverse order of use.\n\t// Therefore build a new, reverted list of dependencies containing only the current\n\t// dependencies in a proper order of use.\n\t// Drop former dependencies from the list and unsubscribe from their change notifications.\n\n\tlet node = target._sources;\n\tlet sources = undefined;\n\twhile (node !== undefined) {\n\t\tconst next = node._nextSource;\n\t\tif (node._flags & NODE_FREE) {\n\t\t\tnode._source._unsubscribe(node);\n\t\t\tnode._nextSource = undefined;\n\t\t} else {\n\t\t\tif (sources !== undefined) {\n\t\t\t\tsources._prevSource = node;\n\t\t\t}\n\t\t\tnode._prevSource = undefined;\n\t\t\tnode._nextSource = sources;\n\t\t\tsources = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\t\tnode = next;\n\t}\n\ttarget._sources = sources;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNIN flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0) {\n\t\t// Check the dependencies for changed values. The dependency list is already\n\t\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t\t// the first used dependency is re-evaluated at this point.\n\t\tlet node = this._sources;\n\t\twhile (node !== undefined) {\n\t\t\t// If a dependency has something blocking it from refreshing (e.g. a dependency\n\t\t\t// cycle) or there's a new version of the dependency, then we need to recompute.\n\t\t\tif (!node._source._refresh() || node._source._version !== node._version) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = node._nextSource;\n\t\t}\n\t\t// If none of the dependencies have changed values since last recompute then the\n\t\t// computed value can't have changed.\n\t\tif (node === undefined) {\n\t\t\tthis._flags &= ~RUNNING;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\tSignal.prototype._unsubscribe.call(this, node);\n\n\t// Computed signal unsubscribes from its dependencies from it loses its last subscriber.\n\tif (this._targets === undefined) {\n\t\tthis._flags &= ~TRACKING;\n\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._unsubscribe(node);\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ndeclare class Effect {\n\t_compute: () => unknown;\n\t_cleanup?: unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => void);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => void) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = OUTDATED | TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (!(this._flags & DISPOSED)) {\n\t\t\tthis._cleanup = this._compute();\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tprepareSources(this);\n\tcleanupEffect(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tthis._flags &= ~OUTDATED;\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED | OUTDATED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown): () => void {\n\tconst effect = new Effect(compute);\n\teffect._callback();\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport { signal, computed, effect, batch, Signal, ReadonlySignal };\n"],"names":["cycleDetected","Error","endBatch","batchDepth","error","hasError","undefined","batchedEffect","effect","batchIteration","next","_nextBatchedEffect","_flags","_callback","err","batch","callback","evalContext","globalVersion","addDependency","signal","node","_node","_target","_version","_source","_prevSource","_nextSource","_sources","_prevTarget","_nextTarget","_rollbackNode","_subscribe","head","prev","Signal","value","this","_value","_targets","prototype","_refresh","_unsubscribe","subscribe","fn","flag","valueOf","toString","peek","Object","defineProperty","get","set","_notify","prepareSources","target","rollbackNode","cleanupSources","sources","Computed","compute","call","_compute","_globalVersion","OUTDATED","prevContext","_node2","computed","cleanupEffect","cleanup","_cleanup","disposeEffect","endEffect","Effect","finish","_start","bind","NOTIFIED","_dispose"],"mappings":"AAAA,SAASA,IACR,MAAM,IAAAC,MAAU,iBAChB,CA8CD,SAASC,IACR,GAAIC,EAAa,EAAG,CACnBA,IACA,MACA,CAED,IAAIC,EACQC,GAAG,EAEf,WAAyBC,IAAlBC,EAA6B,CACnC,IAAIC,EAA6BD,EACjCA,OAAgBD,EAEhBG,IAEA,WAAkBH,IAAXE,EAAsB,CAC5B,MAAUE,EAAuBF,EAAOG,EACxCH,EAAOG,OAAqBL,EAC5BE,EAAOI,IAAU,EAEjB,KA5Dc,EA4DRJ,EAAOI,IA7DC,EA6DqBJ,EAAOI,EACzC,IACCJ,EAAOK,GAMP,CALC,MAAOC,GACR,IAAKT,EAAU,CACdD,EAAQU,EACRT,GAAW,CACX,CACD,CAEFG,EAASE,CACT,CACD,CACDD,EAAiB,EACjBN,IAEA,GAAIE,EACH,MACAD,CACD,CAED,SAAAW,EAAkBC,GACjB,GAAIb,EAAa,EAChB,OAAea,IA9ChBb,IAiDA,IACC,OAAOa,GAGP,CAJD,QAGCd,GACA,CACD,CAGD,IAAIe,EAGaV,EACbJ,EAAa,EACCM,EAAG,EAIjBS,EAAgB,EAEpB,SAAAC,EAAuBC,GACtB,QAAoBd,IAAhBW,EACH,OAGD,IAAQI,EAAGD,EAAOE,EAClB,QAAahB,IAATe,GAAsBA,EAAKE,IAAYN,EAAa,CAGvDI,EAAO,CACNT,EAAQ,EACRY,EAAU,EACVC,EAASL,EACTM,OAAapB,EACbqB,EAAaV,EAAYW,EACzBL,EAASN,EACTY,OAAavB,EACbwB,OAAaxB,EACbyB,EAAeV,GAEhBJ,EAAYW,EAAWP,EACvBD,EAAOE,EAAQD,EAIf,GAhIe,GAgIXJ,EAAYL,EACfQ,EAAOY,EAAWX,GAEnB,OACAA,CAAA,MAAM,GAjIU,EAiINA,EAAKT,EAAoB,CAGnCS,EAAKT,IAAU,EAEf,MAAMqB,EAAOhB,EAAYW,EACzB,GAAIP,IAASY,EAAM,CAClB,MAAMC,EAAOb,EAAKK,EACRhB,EAAGW,EAAKM,EAClB,QAAarB,IAAT4B,EACHA,EAAKP,EAAcjB,EAEpB,QAAaJ,IAATI,EACHA,EAAKgB,EAAcQ,EAEpB,QAAa5B,IAAT2B,EACHA,EAAKP,EAAcL,EAEpBA,EAAKK,OAAcpB,EACnBe,EAAKM,EAAcM,EACnBhB,EAAYW,EAAWP,CACvB,CAID,OACAA,CAAA,CAED,CAuCD,SAAAc,EAA8BC,GAC7BC,KAAKC,EAASF,EACdC,KAAKb,EAAW,EAChBa,KAAKf,OAAQhB,EACb+B,KAAKE,OAAWjC,CAChB,CAED6B,EAAOK,UAAUC,EAAW,WAC3B,OACA,CAAA,EAEDN,EAAOK,UAAUR,EAAa,SAAUX,GACvC,KA/MuB,EA+MjBA,EAAKT,GAA2B,CACrCS,EAAKT,GAhNiB,EAiNtBS,EAAKS,EAAcO,KAAKE,EAExB,QAAsBjC,IAAlB+B,KAAKE,EACRF,KAAKE,EAASV,EAAcR,EAE7BgB,KAAKE,EAAWlB,CAChB,CACD,EAEDc,EAAOK,UAAUE,EAAe,SAAUrB,GACzC,GA3NuB,EA2NnBA,EAAKT,EAA0B,CAClCS,EAAKT,IAAU,EAEf,MAAUsB,EAAGb,EAAKQ,EACZnB,EAAOW,EAAKS,EAClB,QAAaxB,IAAT4B,EAAoB,CACvBA,EAAKJ,EAAcpB,EACnBW,EAAKQ,OAAcvB,CACnB,CACD,QAAaA,IAATI,EAAoB,CACvBA,EAAKmB,EAAcK,EACnBb,EAAKS,OAAcxB,CACnB,CACD,GAAIe,IAASgB,KAAKE,EACjBF,KAAKE,EAAW7B,CAEjB,CACD,EAEDyB,EAAOK,UAAUG,UAAY,SAAUC,GACtC,MAAYxB,EAAGiB,KACf,OAAO7B,EAAO,WACb,MAAW4B,EAAGhB,EAAOgB,MACfS,EAtPS,GAsPFR,KAAKzB,EAClByB,KAAKzB,IAAU,GACf,IACCgC,EAAGR,EAGH,CAJD,QAGCC,KAAKzB,GAAUiC,CACf,CACD,EACD,EAEDV,EAAOK,UAAUM,QAAU,WAC1B,OAAYV,KAAAA,KACZ,EAEDD,EAAOK,UAAUO,SAAW,WAC3B,OAAOV,KAAKD,MAAQ,EACpB,EAEDD,EAAOK,UAAUQ,KAAO,WACvB,OAAYV,KAAAA,CACZ,EAEDW,OAAOC,eAAef,EAAOK,UAAW,QAAS,CAChDW,MACC,MAAU9B,EAAGF,EAAckB,MAC3B,QAAa/B,IAATe,EACHA,EAAKG,EAAWa,KAAKb,EAEtB,OAAOa,KAAKC,CACZ,EACDc,IAAIhB,GACH,GAAIA,IAAUC,KAAKC,EAAQ,CAC1B,GAAI7B,EAAiB,IACpBT,IAGDqC,KAAKC,EAASF,EACdC,KAAKb,IACLN,IAzPFf,IA4PE,IACC,IACC,IAAIkB,EAAOgB,KAAKE,OACPjC,IAATe,EACAA,EAAOA,EAAKS,EAEZT,EAAKE,EAAQ8B,GAId,CAVD,QASCnD,GACA,CACD,CACD,IAGF,SAASkB,EAAUgB,GAClB,OAAO,IAAAD,EAAWC,EAClB,CAED,SAAAkB,EAAwBC,GACvB,IACC,IAAIlC,EAAOkC,EAAO3B,OACTtB,IAATe,EACAA,EAAOA,EAAKM,EACX,CACD,MAAkB6B,EAAGnC,EAAKI,EAAQH,EAClC,QAAqBhB,IAAjBkD,EACHnC,EAAKU,EAAgByB,EAEtBnC,EAAKI,EAAQH,EAAQD,EACrBA,EAAKT,GA1TW,CA2ThB,CACD,CAED,SAAA6C,EAAwBF,GAOvB,IACIG,EADIrC,EAAGkC,EAAO3B,EAElB,WAAgBtB,IAATe,EAAoB,CAC1B,MAAMX,EAAOW,EAAKM,EAClB,GAzUgB,EAyUZN,EAAKT,EAAoB,CAC5BS,EAAKI,EAAQiB,EAAarB,GAC1BA,EAAKM,OAAcrB,CACnB,KAAM,CACN,QAAgBA,IAAZoD,EACHA,EAAQhC,EAAcL,EAEvBA,EAAKK,OAAcpB,EACnBe,EAAKM,EAAc+B,EACnBA,EAAUrC,CACV,CAEDA,EAAKI,EAAQH,EAAQD,EAAKU,EAC1B,QAA2BzB,IAAvBe,EAAKU,EACRV,EAAKU,OAAgBzB,EAEtBe,EAAOX,CACP,CACD6C,EAAO3B,EAAW8B,CAClB,CAcD,SAAAC,EAAkCC,GACjCzB,EAAO0B,KAAKxB,UAAM/B,GAElB+B,KAAKyB,EAAWF,EAChBvB,KAAKT,OAAWtB,EAChB+B,KAAK0B,EAAiB7C,EAAgB,EACtCmB,KAAKzB,EAtXW,CAuXhB,EAED+C,EAASnB,UAAY,IAAIL,GAENM,EAAW,WAC7BJ,KAAKzB,IAAU,EAEf,GAhYe,EAgYXyB,KAAKzB,EACR,OAAO,EAMR,GAlYgB,KAkYIoD,GAAf3B,KAAKzB,GACT,OAAO,EAERyB,KAAKzB,IAAU,EAEf,GAAIyB,KAAK0B,IAAmB7C,EAC3B,OACA,EACDmB,KAAK0B,EAAiB7C,EAItBmB,KAAKzB,GAnZU,EAoZf,GAAIyB,KAAKb,EAAW,EAAG,CAItB,IAAQH,EAAGgB,KAAKT,EAChB,WAAgBtB,IAATe,EAAoB,CAG1B,IAAKA,EAAKI,EAAQgB,KAAcpB,EAAKI,EAAQD,IAAaH,EAAKG,EAC9D,MAEDH,EAAOA,EAAKM,CACZ,CAGD,QAAarB,IAATe,EAAoB,CACvBgB,KAAKzB,IAAU,EACf,OAAO,CACP,CACD,CAED,MAAMqD,EAAchD,EACpB,IACCqC,EAAejB,MACfpB,EAAcoB,KACd,MAAMD,EAAQC,KAAKyB,IACnB,GA1agB,GA2afzB,KAAKzB,GACLyB,KAAKC,IAAWF,GACE,IAAlBC,KAAKb,EACJ,CACDa,KAAKC,EAASF,EACdC,KAAKzB,IAAU,GACfyB,KAAKb,GACL,CAKD,CAJC,MAAOV,GACRuB,KAAKC,EAASxB,EACduB,KAAKzB,GArbW,GAsbhByB,KAAKb,GACL,CACDP,EAAcgD,EACdR,EAAepB,MACfA,KAAKzB,IAAU,EACf,OACA,CAAA,EAED+C,EAASnB,UAAUR,EAAa,SAAUX,GACzC,QAAsBf,IAAlB+B,KAAKE,EAAwB,CAChCF,KAAKzB,GAAUoD,GAIf,IACC,IAAQ1C,EAAGe,KAAKT,OACPtB,IAATe,EACAA,EAAOA,EAAKM,EAEZN,EAAKI,EAAQO,EAAWX,EAEzB,CACDc,EAAOK,UAAUR,EAAW6B,KAAKxB,KAAMhB,EACvC,EAEDsC,EAASnB,UAAUE,EAAe,SAAUrB,GAC3Cc,EAAOK,UAAUE,EAAamB,KAAKxB,KAAMhB,GAGzC,QAAsBf,IAAlB+B,KAAKE,EAAwB,CAChCF,KAAKzB,IAAU,GAEf,IACC,IAAQsD,EAAG7B,KAAKT,OACPtB,IAATe,EACAA,EAAOA,EAAKM,EAEZN,EAAKI,EAAQiB,EAAarB,EAE3B,CACD,EAEDsC,EAASnB,UAAUa,EAAU,WAC5B,KApegB,EAoeVhB,KAAKzB,GAAoB,CAC9ByB,KAAKzB,GAAUoD,EAEf,IACC,IAAI3C,EAAOgB,KAAKE,OACPjC,IAATe,EACAA,EAAOA,EAAKS,EAEZT,EAAKE,EAAQ8B,GAEd,CACD,EAEDM,EAASnB,UAAUQ,KAAO,WACzB,IAAKX,KAAKI,IACTzC,IAED,GAlfiB,GAkfbqC,KAAKzB,EACR,MAAW0B,KAAAA,EAEZ,OAAYA,KAAAA,CACZ,EAEDW,OAAOC,eAAeS,EAASnB,UAAW,QAAS,CAClDW,MACC,GA9fc,EA8fVd,KAAKzB,EACRZ,IAED,MAAUqB,EAAGF,EAAckB,MAC3BA,KAAKI,IACL,QAAanC,IAATe,EACHA,EAAKG,EAAWa,KAAKb,EAEtB,GAlgBgB,GAkgBZa,KAAKzB,EACR,MAAW0B,KAAAA,EAEZ,OAAYA,KAAAA,CACZ,IAOF,SAAA6B,EAAqBP,GACpB,OAAWD,IAAAA,EAASC,EACpB,CAED,SAASQ,EAAc5D,GACtB,MAAM6D,EAAU7D,EAAO8D,EACvB9D,EAAO8D,OAAWhE,EAElB,GAAuB,mBAAZ+D,EAAwB,CAjfnClE,IAqfC,QAAoBc,EACpBA,OAAcX,EACd,IACC+D,GAOA,CANC,MAAOvD,GACRN,EAAOI,IAAU,EACjB,MACAE,CAAA,CALD,QAMCG,EAAcgD,EACd/D,GACA,CACD,CACD,CAED,SAAAqE,EAAuB/D,GACtB,IACC,IAAIa,EAAOb,EAAOoB,OACTtB,IAATe,EACAA,EAAOA,EAAKM,EAEZN,EAAKI,EAAQiB,EAAarB,GAE3Bb,EAAOoB,OAAWtB,EAElB8D,EAAc5D,EACd,CAED,SAAAgE,EAAiCP,GAChC,GAAIhD,IAAgBoB,KACnB,MAAUpC,IAAAA,MAAM,uBAEjBwD,EAAepB,MACfpB,EAAcgD,EAEd5B,KAAKzB,IAAU,EACf,GA7jBgB,EA6jBZyB,KAAKzB,EACR2D,EAAclC,MAEfnC,GACA,CAiBD,SAAAuE,EAA8Bb,GAC7BvB,KAAKyB,EAAWF,EAChBvB,KAAKiC,OAAWhE,EAChB+B,KAAKT,OAAWtB,EAChB+B,KAAK1B,OAAqBL,EAC1B+B,KAAKzB,EAASoD,EACd,CAEDS,EAAOjC,UAAU3B,EAAY,WAC5B,MAAM6D,EAASrC,KAAKsC,IACpB,IACC,KA7lBe,EA6lBTtC,KAAKzB,GACVyB,KAAKiC,EAAWjC,KAAKyB,GAItB,CAND,QAKCY,GACA,CACD,EAEDD,EAAOjC,UAAUmC,EAAS,WACzB,GAzmBe,EAymBXtC,KAAKzB,EACRZ,IAEDqC,KAAKzB,GA5mBU,EA6mBfyB,KAAKzB,IAAU,EACf0C,EAAejB,MACf+B,EAAc/B,MAvkBdlC,IA0kBAkC,KAAKzB,IAAU,EACf,MAAiBqD,EAAGhD,EACpBA,EAAcoB,KACd,OAAOmC,EAAUI,KAAKvC,KAAM4B,EAC5B,EAEDQ,EAAOjC,UAAUa,EAAU,WAC1B,KAxnBgB,EAwnBVhB,KAAKzB,GAAoB,CAC9ByB,KAAKzB,GAAUiE,EACfxC,KAAK1B,EAAqBJ,EAC1BA,EAAgB8B,IAChB,CACD,EAEDoC,EAAOjC,UAAUsC,EAAW,WAC3BzC,KAAKzB,GA9nBW,EAgoBhB,KAnoBe,EAmoBTyB,KAAKzB,GACV2D,EAAclC,KAEf,EAED,SAAS7B,EAAOoD,GACf,MAAMpD,EAAS,IAAAiE,EAAWb,GAC1BpD,EAAOK,IAGP,OAAaL,EAACsE,EAASF,KAAKpE,EAC5B"}