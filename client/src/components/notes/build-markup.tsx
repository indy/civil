import { h } from "preact";

import Image from "components/image";
import YouTube from "components/youtube";
import { getAppState } from "app-state";

type Element = {
    name: string;
    key?: number;
    class_name?: string;

    html_for?: string;
    href?: string;
    src?: string;
    html_type?: string;
    id?: string;
    start?: string;

    children: Array<Element>;
    text?: string;
};

type Attrs = {
    key: number;
    class?: string;
    id?: string;
    for?: string;
    href?: string;
    type?: string;
    src?: string;
    start?: any;
};
// start?: ComponentType<Attrs>;

// build the Preact structure from the AST generated by rust
//
export default function buildMarkup(content: string, options?: any) {
    const appState = getAppState();
    const wasmInterface = appState.wasmInterface!;

    const ignoreRight = options ? options.ignoreRight : false;

    const astArray = wasmInterface.markupAsStruct(content);
    if (!astArray) {
        console.error(`unable to correctly parse: '${content}'`);
        return false;
    }

    function attrs(n: Element): Attrs {
        const res: Attrs = {
            key: n.key!,
        };
        if (n.class_name) {
            res.class = n.class_name;
        }
        if (n.id) {
            res.id = n.id;
        }
        if (n.html_for) {
            res.for = n.html_for;
        }
        if (n.href) {
            res.href = n.href;
        }
        if (n.html_type) {
            res.type = n.html_type;
        }
        if (n.src) {
            res.src = `/u/${appState.imageDirectory.value}/${n.src}`;
        }
        if (n.start) {
            res.start = n.start;
        }

        return res;
    }

    function assignPseudoParagraph(klass?: string) {
        let c = klass || "";
        c += " pseudo-paragraph";
        return c.trim();
    }

    function isOnRightMargin(n: Element): boolean {
        if (!n.class_name) {
            return false;
        }

        let onRight =
            n.class_name.search("right-margin") >= 0 ||
            n.class_name.search("right-margin-numbered") >= 0 ||
            n.class_name.search("right-margin-scribble") >= 0;

        return onRight;
    }

    function isFigureElement(n: Element): boolean {
        return n.name === "figure";
    }

    function compile(n: Element, onRight: boolean, withinFigure: boolean) {
        let isOnRight = onRight || isOnRightMargin(n);
        let isWithinFigure = withinFigure || isFigureElement(n);
        let children = n.children
            .filter((child) => !(ignoreRight && isOnRightMargin(child)))
            .map((child) => compile(child, isOnRight, isWithinFigure));

        if (n.name === "text") {
            return n.text;
        } else if (n.name === "p" && onRight) {
            // we have a nested paragraph (e.g. text in the right-hand margin created by the pipe syntax)
            // as html's <p> tag cannot be nested, use a span with a custom class
            //
            let modified_attrs: Attrs = attrs(n);
            modified_attrs.class = assignPseudoParagraph(modified_attrs.class);

            return h("span", modified_attrs, ...children);
        } else if (n.name === "img") {
            // replace the requested img tag with our own Image component which
            // has more functionality
            //
            if (isOnRight || isWithinFigure) {
                return h(Image, attrs(n), ...children);
            } else {
                // wrap a regular image within a p tag
                return h("p", {}, h(Image, attrs(n), ...children));
            }
        } else if (n.name === "youtube") {
            return h(YouTube, attrs(n), ...children);
        } else {
            return h(n.name, attrs(n), ...children);
        }
    }

    // console.log(astArray);
    return astArray.map((node: Element) => {
        return compile(node, false, false);
    });
}
