// import { h, ComponentType } from "preact";
import { h } from "preact";

import Image from "./Image";
import { getAppState } from "../AppState";

type Element = {
    name: string;
    key?: number;
    class_name?: string;

    html_for?: string;
    href?: string;
    src?: string;
    html_type?: string;
    id?: string;
    start?: string;

    children: Array<Element>;
    text?: string;
};

type Attrs = {
    key: number;
    class?: string;
    id?: string;
    for?: string;
    href?: string;
    type?: string;
    src?: string;
    start?: any;
};
// start?: ComponentType<Attrs>;

// build the Preact structure from the AST generated by rust
//
export default function buildMarkup(content: string) {
    const appState = getAppState();
    const wasmInterface = appState.wasmInterface!;

    const astArray = wasmInterface.asHtmlAst(content);

    function attrs(n: Element): Attrs {
        const res: Attrs = {
            key: n.key!,
        };
        if (n.class_name) {
            res.class = n.class_name;
        }
        if (n.id) {
            res.id = n.id;
        }
        if (n.html_for) {
            res.for = n.html_for;
        }
        if (n.href) {
            res.href = n.href;
        }
        if (n.html_type) {
            res.type = n.html_type;
        }
        if (n.src) {
            res.src = `/u/${appState.imageDirectory.value}/${n.src}`;
        }
        if (n.start) {
            res.start = n.start;
        }

        return res;
    }

    function assignPseudoParagraph(klass?: string) {
        let c = klass || "";
        c += " pseudo-paragraph";
        return c.trim();
    }

    function compile(n: Element, withinRightMargin: boolean) {
        if (!withinRightMargin && n.class_name) {
            // set withinRightMargin to true for all subsequent children
            withinRightMargin =
                n.class_name.search("right-margin") >= 0 ||
                n.class_name.search("right-margin-numbered") >= 0 ||
                n.class_name.search("right-margin-scribble") >= 0;
        }

        if (n.name === "text") {
            return n.text;
        } else if (n.name === "p") {
            if (withinRightMargin) {
                // we have a nested paragraph (e.g. text in the right-hand margin created by the pipe syntax)
                // as html's <p> tag cannot be nested, use a span with a custom class
                //
                let modified_attrs: Attrs = attrs(n);
                modified_attrs.class = assignPseudoParagraph(
                    modified_attrs.class
                );
                return h(
                    "span",
                    modified_attrs,
                    ...n.children.map((child) => {
                        return compile(child, withinRightMargin);
                    })
                );
            } else {
                return h(
                    n.name,
                    attrs(n),
                    ...n.children.map((child) => {
                        return compile(child, withinRightMargin);
                    })
                );
            }
        } else if (n.name === "img") {
            // replace the requested img tag with our own Image component which
            // has more functionality
            //
            return h(
                Image,
                attrs(n),
                ...n.children.map((child) => {
                    return compile(child, withinRightMargin);
                })
            );
        } else {
            return h(
                n.name,
                attrs(n),
                ...n.children.map((child) => {
                    return compile(child, withinRightMargin);
                })
            );
        }
    }

    // console.log(astArray);
    return astArray.map((node: Element) => {
        return compile(node, false);
    });
}
